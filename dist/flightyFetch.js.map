{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 395c3d175a9bea7638f9","webpack:///./dist/flightyFetch.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,6DAA4D,gBAAgB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA,qDAAoD,oBAAoB,EAAE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,6BAA6B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC","file":"flightyFetch.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"flightyFetch\"] = factory();\n\telse\n\t\troot[\"flightyFetch\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 395c3d175a9bea7638f9\n **/","\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\n/**\r\n * Fetches a resource like the standard fetch function, but with support for cancellation.\r\n *\r\n * @param input the url or request\r\n * @param options (optional) any options for initializing the request\r\n * @return a promise of the response to the fetch request\r\n */\r\nfunction fetch(input, options) {\r\n    function promiseCallback(resolve, reject) {\r\n        var request;\r\n        if (Request.prototype.isPrototypeOf(input) && !options) {\r\n            request = input;\r\n        }\r\n        else {\r\n            request = new Request(input, options);\r\n        }\r\n        var cancellationPromise;\r\n        var cancellationToken;\r\n        if (options) {\r\n            cancellationPromise = options.cancellationPromise;\r\n            cancellationToken = options.cancellationToken;\r\n        }\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.onload = function () {\r\n            try {\r\n                var status = xhr.status;\r\n                if (xhr.status === 1223) {\r\n                    status = 204;\r\n                }\r\n                if (status < 100 || status >= 600) {\r\n                    reject(new TypeError('Network request failed'));\r\n                    return;\r\n                }\r\n                var responseBody;\r\n                if ('response' in xhr) {\r\n                    responseBody = xhr.response;\r\n                }\r\n                else {\r\n                    responseBody = xhr.responseText;\r\n                }\r\n                // Having an empty blob for a body can break things with some status codes in chrome.\r\n                if (status != 200) {\r\n                    responseBody = normalizeBody(responseBody);\r\n                }\r\n                var responseHeaders = parseResponseHeaders(xhr);\r\n                var responseOptions = {\r\n                    status: status,\r\n                    statusText: xhr.statusText,\r\n                    headers: responseHeaders,\r\n                    url: xhr.responseURL\r\n                };\r\n                var response = new Response(responseBody, responseOptions);\r\n                resolve(response);\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        };\r\n        xhr.onerror = function () {\r\n            reject(new TypeError('Network request failed'));\r\n        };\r\n        xhr.ontimeout = function () {\r\n            reject(new TypeError('Network request failed'));\r\n        };\r\n        xhr.onabort = function () {\r\n            reject(new CancellationError('The request was cancelled'));\r\n        };\r\n        xhr.open(request.method, request.url, true);\r\n        if (typeof request.headers.forEach === 'function') {\r\n            // Chrome and the github/fetch polyfill have a forEach function.\r\n            request.headers.forEach(function (value, name) {\r\n                xhr.setRequestHeader(name, value);\r\n            });\r\n        }\r\n        else if (typeof request.headers.entries === 'function') {\r\n            // Firefox doesn't have forEach, but it does have an entries function.\r\n            for (var _i = 0, _a = request.headers.entries(); _i < _a.length; _i++) {\r\n                var pair = _a[_i];\r\n                xhr.setRequestHeader(pair[0], pair[1]);\r\n            }\r\n        }\r\n        if (request.credentials === 'include') {\r\n            xhr.withCredentials = true;\r\n        }\r\n        if ('responseType' in xhr && typeof request.blob === 'function') {\r\n            xhr.responseType = 'blob';\r\n        }\r\n        if (cancellationPromise && typeof cancellationPromise.then === 'function') {\r\n            cancellationPromise.then(function (isCancellationRequested) {\r\n                if (isCancellationRequested) {\r\n                    xhr.abort();\r\n                }\r\n            }).catch(function (e) {\r\n                // We don't care about an error, but some browsers (Chrome) will \r\n                // put an error in the console if we don't have a handler for it.\r\n            });\r\n        }\r\n        if (cancellationToken && typeof cancellationToken.register === 'function') {\r\n            cancellationToken.register(function () { return xhr.abort(); });\r\n        }\r\n        getRequestDataAsync(request).then(function (data) {\r\n            try {\r\n                xhr.send(data);\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        }).catch(function (e) {\r\n            reject(e);\r\n        });\r\n    }\r\n    return new Promise(function (resolve, reject) {\r\n        try {\r\n            promiseCallback(resolve, reject);\r\n        }\r\n        catch (e) {\r\n            reject(e);\r\n        }\r\n    });\r\n}\r\nexports.fetch = fetch;\r\n/**\r\n * A token used to indicate the cancellation status of an operation.\r\n */\r\nvar CancellationToken = (function () {\r\n    /**\r\n     * Constructs a token that requests cancellation when the executor's cancel is called.\r\n     *\r\n     * @param a function that will be called immediately to provide access to a cancel function and a and dispose function\r\n     */\r\n    function CancellationToken(executor) {\r\n        this._isCancellationRequested = false;\r\n        this._onCancelledCallbacks = [];\r\n        var ct = this;\r\n        function cancel() {\r\n            if (ct._onCancelledCallbacks === null)\r\n                throw new Error('The token has been disposed.');\r\n            ct._isCancellationRequested = true;\r\n            var onCancelledCallbacks = ct._onCancelledCallbacks;\r\n            while (onCancelledCallbacks.length > 0) {\r\n                var onCancelled = onCancelledCallbacks.pop();\r\n                onCancelled();\r\n            }\r\n        }\r\n        function dispose() {\r\n            ct._onCancelledCallbacks = null;\r\n        }\r\n        executor(cancel, dispose);\r\n    }\r\n    Object.defineProperty(CancellationToken.prototype, \"isCancellationRequested\", {\r\n        /**\r\n         * Returns true if cancellation has been requested by the source of this token.\r\n         */\r\n        get: function () {\r\n            return this._isCancellationRequested;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Registers a callback to be called when cancellation is requested for this token.\r\n     * If the token has already been cancelled then the callback will be called immediately.\r\n     *\r\n     * @param callback a function that will be called when and if the token is cancelled\r\n     */\r\n    CancellationToken.prototype.register = function (onCancelled) {\r\n        if (typeof (onCancelled) !== 'function')\r\n            throw new Error('onCancelled must be a function');\r\n        if (this._onCancelledCallbacks === null)\r\n            throw new Error('The token has been disposed.');\r\n        if (this._isCancellationRequested === true) {\r\n            onCancelled();\r\n            return;\r\n        }\r\n        this._onCancelledCallbacks.push(onCancelled);\r\n    };\r\n    return CancellationToken;\r\n}());\r\nexports.CancellationToken = CancellationToken;\r\n/**\r\n * An error thrown if a fetch is cancelled.\r\n */\r\nvar CancellationError = (function (_super) {\r\n    __extends(CancellationError, _super);\r\n    /**\r\n     * Constructs a cancellation error with the specified message.\r\n     *\r\n     * @param message the message for this error\r\n     */\r\n    function CancellationError(message) {\r\n        _super.call(this, message);\r\n        this.message = message;\r\n        this.name = 'CancellationError';\r\n        this.message = message;\r\n    }\r\n    /**\r\n     * Returns a string that includes the error name and message.\r\n     */\r\n    CancellationError.prototype.toString = function () {\r\n        return this.name + ': ' + this.message;\r\n    };\r\n    return CancellationError;\r\n}(Error));\r\nexports.CancellationError = CancellationError;\r\n/**\r\n * Parses the response headers from an XMLHttpRequest to a fetch api Headers object.\r\n */\r\nfunction parseResponseHeaders(xhr) {\r\n    var result = new Headers();\r\n    var headerStrings = (xhr.getAllResponseHeaders() || '').trim().split('\\n');\r\n    for (var _i = 0, headerStrings_1 = headerStrings; _i < headerStrings_1.length; _i++) {\r\n        var headerString = headerStrings_1[_i];\r\n        var separatorIndex = headerString.indexOf(':');\r\n        if (separatorIndex < 0) {\r\n            continue;\r\n        }\r\n        var name_1 = headerString.substr(0, separatorIndex).trim();\r\n        var value = headerString.substr(separatorIndex + 1).trim();\r\n        try {\r\n            result.append(name_1, value);\r\n        }\r\n        catch (e) {\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Returns a promise of the data from a Request object.\r\n */\r\nfunction getRequestDataAsync(request) {\r\n    // The github/fetch polyfill may have the original body in a secret variable.\r\n    // So I guess we'll use that if it's available?\r\n    if ('_bodyInit' in request) {\r\n        return Promise.resolve(request._bodyInit);\r\n    }\r\n    var result;\r\n    var contentType = parseContentType(request) || '';\r\n    if (stringStartsWith(contentType, 'text/')) {\r\n        result = request.text();\r\n    }\r\n    else if (typeof request.blob === 'function') {\r\n        result = request.blob();\r\n    }\r\n    else {\r\n        result = request.text();\r\n    }\r\n    // We don't want to send anything if the body is empty\r\n    result = result.then(normalizeBody);\r\n    return result;\r\n}\r\n/**\r\n * Parses and returns the content type from a fetch api Request object.\r\n */\r\nfunction parseContentType(request) {\r\n    if (!request || !request.headers)\r\n        return null;\r\n    var contentType = request.headers.get('content-type');\r\n    if (!contentType)\r\n        return null;\r\n    var paramSeparatorIndex = contentType.indexOf(';');\r\n    if (paramSeparatorIndex >= 0) {\r\n        contentType = contentType.substr(0, paramSeparatorIndex).trim();\r\n    }\r\n    contentType = contentType.toLowerCase();\r\n    return contentType;\r\n}\r\n/**\r\n * Returns the given request/response body if it is not empty, otherwise returns undefined.\r\n */\r\nfunction normalizeBody(bodyInit) {\r\n    var modifiedBodyInit = bodyInit;\r\n    if (modifiedBodyInit) {\r\n        if (typeof bodyInit.size === 'number' && bodyInit.size === 0) {\r\n            modifiedBodyInit = undefined;\r\n        }\r\n        else if (typeof bodyInit.length === 'number' && bodyInit.length === 0) {\r\n            modifiedBodyInit = undefined;\r\n        }\r\n    }\r\n    return modifiedBodyInit;\r\n}\r\n/**\r\n * Returns true if the string begins with the characters of the specified searchString.\r\n */\r\nfunction stringStartsWith(str, searchString) {\r\n    if (typeof str.startsWith === 'function') {\r\n        return str.startsWith(searchString);\r\n    }\r\n    return str.substr(0, searchString.length) === searchString;\r\n}\r\n//# sourceMappingURL=flightyFetch.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./dist/flightyFetch.js\n ** module id = 0\n ** module chunks = 0\n **/"],"sourceRoot":""}